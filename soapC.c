/* soapC.c
   Generated by gSOAP 2.8.122 for operations.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.122 2022-06-15 10:02:55 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	if (!soap->fault)
		return NULL;
	if (soap->version == 2)
		return soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode ? soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value : NULL;
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTo_ns1__totalServFilesSizeResponse1:
		return soap_in_PointerTo_ns1__totalServFilesSizeResponse1(soap, tag, NULL, "ns1:totalServFilesSizeResponse1");
	case SOAP_TYPE_PointerTo_ns1__totalServFilesSize:
		return soap_in_PointerTo_ns1__totalServFilesSize(soap, tag, NULL, "ns1:totalServFilesSize");
	case SOAP_TYPE_PointerTo_ns1__filesStatisticsResponse1:
		return soap_in_PointerTo_ns1__filesStatisticsResponse1(soap, tag, NULL, "ns1:filesStatisticsResponse1");
	case SOAP_TYPE_PointerTo_ns1__filesStatistics:
		return soap_in_PointerTo_ns1__filesStatistics(soap, tag, NULL, "ns1:filesStatistics");
	case SOAP_TYPE_PointerTo_ns1__smallestServFileResponse1:
		return soap_in_PointerTo_ns1__smallestServFileResponse1(soap, tag, NULL, "ns1:smallestServFileResponse1");
	case SOAP_TYPE_PointerTo_ns1__smallestServFile:
		return soap_in_PointerTo_ns1__smallestServFile(soap, tag, NULL, "ns1:smallestServFile");
	case SOAP_TYPE_PointerTo_ns1__largestServFileResponse1:
		return soap_in_PointerTo_ns1__largestServFileResponse1(soap, tag, NULL, "ns1:largestServFileResponse1");
	case SOAP_TYPE_PointerTo_ns1__largestServFile:
		return soap_in_PointerTo_ns1__largestServFile(soap, tag, NULL, "ns1:largestServFile");
	case SOAP_TYPE_PointerTo_ns1__filesInCertainProgLanguageResponse1:
		return soap_in_PointerTo_ns1__filesInCertainProgLanguageResponse1(soap, tag, NULL, "ns1:filesInCertainProgLanguageResponse1");
	case SOAP_TYPE_PointerTo_ns1__filesInCertainProgLanguage:
		return soap_in_PointerTo_ns1__filesInCertainProgLanguage(soap, tag, NULL, "ns1:filesInCertainProgLanguage");
	case SOAP_TYPE_PointerTo_ns1__servFilesResponse1:
		return soap_in_PointerTo_ns1__servFilesResponse1(soap, tag, NULL, "ns1:servFilesResponse1");
	case SOAP_TYPE_PointerTo_ns1__servFiles:
		return soap_in_PointerTo_ns1__servFiles(soap, tag, NULL, "ns1:servFiles");
	case SOAP_TYPE_PointerTo_ns1__clientLogFilesResponse1:
		return soap_in_PointerTo_ns1__clientLogFilesResponse1(soap, tag, NULL, "ns1:clientLogFilesResponse1");
	case SOAP_TYPE_PointerTo_ns1__clientLogFiles:
		return soap_in_PointerTo_ns1__clientLogFiles(soap, tag, NULL, "ns1:clientLogFiles");
	case SOAP_TYPE_PointerTo_ns1__removeFileResponse:
		return soap_in_PointerTo_ns1__removeFileResponse(soap, tag, NULL, "ns1:removeFileResponse");
	case SOAP_TYPE_PointerTo_ns1__removeFile:
		return soap_in_PointerTo_ns1__removeFile(soap, tag, NULL, "ns1:removeFile");
	case SOAP_TYPE_PointerTo_ns1__modifyFileResponse:
		return soap_in_PointerTo_ns1__modifyFileResponse(soap, tag, NULL, "ns1:modifyFileResponse");
	case SOAP_TYPE_PointerTo_ns1__modifyFile:
		return soap_in_PointerTo_ns1__modifyFile(soap, tag, NULL, "ns1:modifyFile");
	case SOAP_TYPE_PointerTo_ns1__createFileResponse:
		return soap_in_PointerTo_ns1__createFileResponse(soap, tag, NULL, "ns1:createFileResponse");
	case SOAP_TYPE_PointerTo_ns1__createFile:
		return soap_in_PointerTo_ns1__createFile(soap, tag, NULL, "ns1:createFile");
	case SOAP_TYPE_PointerTo_ns1__storeFileResponse:
		return soap_in_PointerTo_ns1__storeFileResponse(soap, tag, NULL, "ns1:storeFileResponse");
	case SOAP_TYPE_PointerTo_ns1__storeFile:
		return soap_in_PointerTo_ns1__storeFile(soap, tag, NULL, "ns1:storeFile");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:totalServFilesSizeResponse1"))
		{	*type = SOAP_TYPE__ns1__totalServFilesSizeResponse1;
			return soap_in__ns1__totalServFilesSizeResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:totalServFilesSize"))
		{	*type = SOAP_TYPE__ns1__totalServFilesSize;
			return soap_in__ns1__totalServFilesSize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:filesStatisticsResponse1"))
		{	*type = SOAP_TYPE__ns1__filesStatisticsResponse1;
			return soap_in__ns1__filesStatisticsResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:filesStatistics"))
		{	*type = SOAP_TYPE__ns1__filesStatistics;
			return soap_in__ns1__filesStatistics(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:smallestServFileResponse1"))
		{	*type = SOAP_TYPE__ns1__smallestServFileResponse1;
			return soap_in__ns1__smallestServFileResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:smallestServFile"))
		{	*type = SOAP_TYPE__ns1__smallestServFile;
			return soap_in__ns1__smallestServFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:largestServFileResponse1"))
		{	*type = SOAP_TYPE__ns1__largestServFileResponse1;
			return soap_in__ns1__largestServFileResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:largestServFile"))
		{	*type = SOAP_TYPE__ns1__largestServFile;
			return soap_in__ns1__largestServFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:filesInCertainProgLanguageResponse1"))
		{	*type = SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1;
			return soap_in__ns1__filesInCertainProgLanguageResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:filesInCertainProgLanguage"))
		{	*type = SOAP_TYPE__ns1__filesInCertainProgLanguage;
			return soap_in__ns1__filesInCertainProgLanguage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:servFilesResponse1"))
		{	*type = SOAP_TYPE__ns1__servFilesResponse1;
			return soap_in__ns1__servFilesResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:servFiles"))
		{	*type = SOAP_TYPE__ns1__servFiles;
			return soap_in__ns1__servFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:clientLogFilesResponse1"))
		{	*type = SOAP_TYPE__ns1__clientLogFilesResponse1;
			return soap_in__ns1__clientLogFilesResponse1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NewOperationResponse"))
		{	*type = SOAP_TYPE__ns1__NewOperationResponse;
			return soap_in__ns1__NewOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:clientLogFiles"))
		{	*type = SOAP_TYPE__ns1__clientLogFiles;
			return soap_in__ns1__clientLogFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:store_exec_fileResponse"))
		{	*type = SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse;
			return soap_in__ns1__store_USCOREexec_USCOREfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:store_exec_file"))
		{	*type = SOAP_TYPE__ns1__store_USCOREexec_USCOREfile;
			return soap_in__ns1__store_USCOREexec_USCOREfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeFileResponse"))
		{	*type = SOAP_TYPE__ns1__removeFileResponse;
			return soap_in__ns1__removeFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeFile"))
		{	*type = SOAP_TYPE__ns1__removeFile;
			return soap_in__ns1__removeFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyFileResponse"))
		{	*type = SOAP_TYPE__ns1__modifyFileResponse;
			return soap_in__ns1__modifyFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyFile"))
		{	*type = SOAP_TYPE__ns1__modifyFile;
			return soap_in__ns1__modifyFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createFileResponse"))
		{	*type = SOAP_TYPE__ns1__createFileResponse;
			return soap_in__ns1__createFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createFile"))
		{	*type = SOAP_TYPE__ns1__createFile;
			return soap_in__ns1__createFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeFileResponse"))
		{	*type = SOAP_TYPE__ns1__storeFileResponse;
			return soap_in__ns1__storeFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeFile"))
		{	*type = SOAP_TYPE__ns1__storeFile;
			return soap_in__ns1__storeFile(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__ns1__totalServFilesSizeResponse1:
		return soap_out__ns1__totalServFilesSizeResponse1(soap, "ns1:totalServFilesSizeResponse1", id, (const struct _ns1__totalServFilesSizeResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__totalServFilesSize:
		return soap_out__ns1__totalServFilesSize(soap, "ns1:totalServFilesSize", id, (const struct _ns1__totalServFilesSize *)ptr, "");
	case SOAP_TYPE__ns1__filesStatisticsResponse1:
		return soap_out__ns1__filesStatisticsResponse1(soap, "ns1:filesStatisticsResponse1", id, (const struct _ns1__filesStatisticsResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__filesStatistics:
		return soap_out__ns1__filesStatistics(soap, "ns1:filesStatistics", id, (const struct _ns1__filesStatistics *)ptr, "");
	case SOAP_TYPE__ns1__smallestServFileResponse1:
		return soap_out__ns1__smallestServFileResponse1(soap, "ns1:smallestServFileResponse1", id, (const struct _ns1__smallestServFileResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__smallestServFile:
		return soap_out__ns1__smallestServFile(soap, "ns1:smallestServFile", id, (const struct _ns1__smallestServFile *)ptr, "");
	case SOAP_TYPE__ns1__largestServFileResponse1:
		return soap_out__ns1__largestServFileResponse1(soap, "ns1:largestServFileResponse1", id, (const struct _ns1__largestServFileResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__largestServFile:
		return soap_out__ns1__largestServFile(soap, "ns1:largestServFile", id, (const struct _ns1__largestServFile *)ptr, "");
	case SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1:
		return soap_out__ns1__filesInCertainProgLanguageResponse1(soap, "ns1:filesInCertainProgLanguageResponse1", id, (const struct _ns1__filesInCertainProgLanguageResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__filesInCertainProgLanguage:
		return soap_out__ns1__filesInCertainProgLanguage(soap, "ns1:filesInCertainProgLanguage", id, (const struct _ns1__filesInCertainProgLanguage *)ptr, "");
	case SOAP_TYPE__ns1__servFilesResponse1:
		return soap_out__ns1__servFilesResponse1(soap, "ns1:servFilesResponse1", id, (const struct _ns1__servFilesResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__servFiles:
		return soap_out__ns1__servFiles(soap, "ns1:servFiles", id, (const struct _ns1__servFiles *)ptr, "");
	case SOAP_TYPE__ns1__clientLogFilesResponse1:
		return soap_out__ns1__clientLogFilesResponse1(soap, "ns1:clientLogFilesResponse1", id, (const struct _ns1__clientLogFilesResponse1 *)ptr, "");
	case SOAP_TYPE__ns1__NewOperationResponse:
		return soap_out__ns1__NewOperationResponse(soap, "ns1:NewOperationResponse", id, (const struct _ns1__NewOperationResponse *)ptr, "");
	case SOAP_TYPE__ns1__clientLogFiles:
		return soap_out__ns1__clientLogFiles(soap, "ns1:clientLogFiles", id, (const struct _ns1__clientLogFiles *)ptr, "");
	case SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse:
		return soap_out__ns1__store_USCOREexec_USCOREfileResponse(soap, "ns1:store_exec_fileResponse", id, (const struct _ns1__store_USCOREexec_USCOREfileResponse *)ptr, "");
	case SOAP_TYPE__ns1__store_USCOREexec_USCOREfile:
		return soap_out__ns1__store_USCOREexec_USCOREfile(soap, "ns1:store_exec_file", id, (const struct _ns1__store_USCOREexec_USCOREfile *)ptr, "");
	case SOAP_TYPE__ns1__removeFileResponse:
		return soap_out__ns1__removeFileResponse(soap, "ns1:removeFileResponse", id, (const struct _ns1__removeFileResponse *)ptr, "");
	case SOAP_TYPE__ns1__removeFile:
		return soap_out__ns1__removeFile(soap, "ns1:removeFile", id, (const struct _ns1__removeFile *)ptr, "");
	case SOAP_TYPE__ns1__modifyFileResponse:
		return soap_out__ns1__modifyFileResponse(soap, "ns1:modifyFileResponse", id, (const struct _ns1__modifyFileResponse *)ptr, "");
	case SOAP_TYPE__ns1__modifyFile:
		return soap_out__ns1__modifyFile(soap, "ns1:modifyFile", id, (const struct _ns1__modifyFile *)ptr, "");
	case SOAP_TYPE__ns1__createFileResponse:
		return soap_out__ns1__createFileResponse(soap, "ns1:createFileResponse", id, (const struct _ns1__createFileResponse *)ptr, "");
	case SOAP_TYPE__ns1__createFile:
		return soap_out__ns1__createFile(soap, "ns1:createFile", id, (const struct _ns1__createFile *)ptr, "");
	case SOAP_TYPE__ns1__storeFileResponse:
		return soap_out__ns1__storeFileResponse(soap, "ns1:storeFileResponse", id, (const struct _ns1__storeFileResponse *)ptr, "");
	case SOAP_TYPE__ns1__storeFile:
		return soap_out__ns1__storeFile(soap, "ns1:storeFile", id, (const struct _ns1__storeFile *)ptr, "");
	case SOAP_TYPE_PointerTo_ns1__totalServFilesSizeResponse1:
		return soap_out_PointerTo_ns1__totalServFilesSizeResponse1(soap, tag, id, (struct _ns1__totalServFilesSizeResponse1 *const*)ptr, "ns1:totalServFilesSizeResponse1");
	case SOAP_TYPE_PointerTo_ns1__totalServFilesSize:
		return soap_out_PointerTo_ns1__totalServFilesSize(soap, tag, id, (struct _ns1__totalServFilesSize *const*)ptr, "ns1:totalServFilesSize");
	case SOAP_TYPE_PointerTo_ns1__filesStatisticsResponse1:
		return soap_out_PointerTo_ns1__filesStatisticsResponse1(soap, tag, id, (struct _ns1__filesStatisticsResponse1 *const*)ptr, "ns1:filesStatisticsResponse1");
	case SOAP_TYPE_PointerTo_ns1__filesStatistics:
		return soap_out_PointerTo_ns1__filesStatistics(soap, tag, id, (struct _ns1__filesStatistics *const*)ptr, "ns1:filesStatistics");
	case SOAP_TYPE_PointerTo_ns1__smallestServFileResponse1:
		return soap_out_PointerTo_ns1__smallestServFileResponse1(soap, tag, id, (struct _ns1__smallestServFileResponse1 *const*)ptr, "ns1:smallestServFileResponse1");
	case SOAP_TYPE_PointerTo_ns1__smallestServFile:
		return soap_out_PointerTo_ns1__smallestServFile(soap, tag, id, (struct _ns1__smallestServFile *const*)ptr, "ns1:smallestServFile");
	case SOAP_TYPE_PointerTo_ns1__largestServFileResponse1:
		return soap_out_PointerTo_ns1__largestServFileResponse1(soap, tag, id, (struct _ns1__largestServFileResponse1 *const*)ptr, "ns1:largestServFileResponse1");
	case SOAP_TYPE_PointerTo_ns1__largestServFile:
		return soap_out_PointerTo_ns1__largestServFile(soap, tag, id, (struct _ns1__largestServFile *const*)ptr, "ns1:largestServFile");
	case SOAP_TYPE_PointerTo_ns1__filesInCertainProgLanguageResponse1:
		return soap_out_PointerTo_ns1__filesInCertainProgLanguageResponse1(soap, tag, id, (struct _ns1__filesInCertainProgLanguageResponse1 *const*)ptr, "ns1:filesInCertainProgLanguageResponse1");
	case SOAP_TYPE_PointerTo_ns1__filesInCertainProgLanguage:
		return soap_out_PointerTo_ns1__filesInCertainProgLanguage(soap, tag, id, (struct _ns1__filesInCertainProgLanguage *const*)ptr, "ns1:filesInCertainProgLanguage");
	case SOAP_TYPE_PointerTo_ns1__servFilesResponse1:
		return soap_out_PointerTo_ns1__servFilesResponse1(soap, tag, id, (struct _ns1__servFilesResponse1 *const*)ptr, "ns1:servFilesResponse1");
	case SOAP_TYPE_PointerTo_ns1__servFiles:
		return soap_out_PointerTo_ns1__servFiles(soap, tag, id, (struct _ns1__servFiles *const*)ptr, "ns1:servFiles");
	case SOAP_TYPE_PointerTo_ns1__clientLogFilesResponse1:
		return soap_out_PointerTo_ns1__clientLogFilesResponse1(soap, tag, id, (struct _ns1__clientLogFilesResponse1 *const*)ptr, "ns1:clientLogFilesResponse1");
	case SOAP_TYPE_PointerTo_ns1__clientLogFiles:
		return soap_out_PointerTo_ns1__clientLogFiles(soap, tag, id, (struct _ns1__clientLogFiles *const*)ptr, "ns1:clientLogFiles");
	case SOAP_TYPE_PointerTo_ns1__removeFileResponse:
		return soap_out_PointerTo_ns1__removeFileResponse(soap, tag, id, (struct _ns1__removeFileResponse *const*)ptr, "ns1:removeFileResponse");
	case SOAP_TYPE_PointerTo_ns1__removeFile:
		return soap_out_PointerTo_ns1__removeFile(soap, tag, id, (struct _ns1__removeFile *const*)ptr, "ns1:removeFile");
	case SOAP_TYPE_PointerTo_ns1__modifyFileResponse:
		return soap_out_PointerTo_ns1__modifyFileResponse(soap, tag, id, (struct _ns1__modifyFileResponse *const*)ptr, "ns1:modifyFileResponse");
	case SOAP_TYPE_PointerTo_ns1__modifyFile:
		return soap_out_PointerTo_ns1__modifyFile(soap, tag, id, (struct _ns1__modifyFile *const*)ptr, "ns1:modifyFile");
	case SOAP_TYPE_PointerTo_ns1__createFileResponse:
		return soap_out_PointerTo_ns1__createFileResponse(soap, tag, id, (struct _ns1__createFileResponse *const*)ptr, "ns1:createFileResponse");
	case SOAP_TYPE_PointerTo_ns1__createFile:
		return soap_out_PointerTo_ns1__createFile(soap, tag, id, (struct _ns1__createFile *const*)ptr, "ns1:createFile");
	case SOAP_TYPE_PointerTo_ns1__storeFileResponse:
		return soap_out_PointerTo_ns1__storeFileResponse(soap, tag, id, (struct _ns1__storeFileResponse *const*)ptr, "ns1:storeFileResponse");
	case SOAP_TYPE_PointerTo_ns1__storeFile:
		return soap_out_PointerTo_ns1__storeFile(soap, tag, id, (struct _ns1__storeFile *const*)ptr, "ns1:storeFile");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.c\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__totalServFilesSize:
		soap_serialize___ns1__totalServFilesSize(soap, (const struct __ns1__totalServFilesSize *)ptr);
		break;
	case SOAP_TYPE___ns1__filesStatistics:
		soap_serialize___ns1__filesStatistics(soap, (const struct __ns1__filesStatistics *)ptr);
		break;
	case SOAP_TYPE___ns1__smallestServFile:
		soap_serialize___ns1__smallestServFile(soap, (const struct __ns1__smallestServFile *)ptr);
		break;
	case SOAP_TYPE___ns1__largestServFile:
		soap_serialize___ns1__largestServFile(soap, (const struct __ns1__largestServFile *)ptr);
		break;
	case SOAP_TYPE___ns1__filesInCertainProgLanguage:
		soap_serialize___ns1__filesInCertainProgLanguage(soap, (const struct __ns1__filesInCertainProgLanguage *)ptr);
		break;
	case SOAP_TYPE___ns1__servFiles:
		soap_serialize___ns1__servFiles(soap, (const struct __ns1__servFiles *)ptr);
		break;
	case SOAP_TYPE___ns1__clientLogFiles:
		soap_serialize___ns1__clientLogFiles(soap, (const struct __ns1__clientLogFiles *)ptr);
		break;
	case SOAP_TYPE___ns1__removeFile:
		soap_serialize___ns1__removeFile(soap, (const struct __ns1__removeFile *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyFile:
		soap_serialize___ns1__modifyFile(soap, (const struct __ns1__modifyFile *)ptr);
		break;
	case SOAP_TYPE___ns1__createFile:
		soap_serialize___ns1__createFile(soap, (const struct __ns1__createFile *)ptr);
		break;
	case SOAP_TYPE___ns1__storeFile:
		soap_serialize___ns1__storeFile(soap, (const struct __ns1__storeFile *)ptr);
		break;
	case SOAP_TYPE__ns1__totalServFilesSizeResponse1:
		soap_serialize__ns1__totalServFilesSizeResponse1(soap, (const struct _ns1__totalServFilesSizeResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__totalServFilesSize:
		soap_serialize__ns1__totalServFilesSize(soap, (const struct _ns1__totalServFilesSize *)ptr);
		break;
	case SOAP_TYPE__ns1__filesStatisticsResponse1:
		soap_serialize__ns1__filesStatisticsResponse1(soap, (const struct _ns1__filesStatisticsResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__filesStatistics:
		soap_serialize__ns1__filesStatistics(soap, (const struct _ns1__filesStatistics *)ptr);
		break;
	case SOAP_TYPE__ns1__smallestServFileResponse1:
		soap_serialize__ns1__smallestServFileResponse1(soap, (const struct _ns1__smallestServFileResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__smallestServFile:
		soap_serialize__ns1__smallestServFile(soap, (const struct _ns1__smallestServFile *)ptr);
		break;
	case SOAP_TYPE__ns1__largestServFileResponse1:
		soap_serialize__ns1__largestServFileResponse1(soap, (const struct _ns1__largestServFileResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__largestServFile:
		soap_serialize__ns1__largestServFile(soap, (const struct _ns1__largestServFile *)ptr);
		break;
	case SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1:
		soap_serialize__ns1__filesInCertainProgLanguageResponse1(soap, (const struct _ns1__filesInCertainProgLanguageResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__filesInCertainProgLanguage:
		soap_serialize__ns1__filesInCertainProgLanguage(soap, (const struct _ns1__filesInCertainProgLanguage *)ptr);
		break;
	case SOAP_TYPE__ns1__servFilesResponse1:
		soap_serialize__ns1__servFilesResponse1(soap, (const struct _ns1__servFilesResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__servFiles:
		soap_serialize__ns1__servFiles(soap, (const struct _ns1__servFiles *)ptr);
		break;
	case SOAP_TYPE__ns1__clientLogFilesResponse1:
		soap_serialize__ns1__clientLogFilesResponse1(soap, (const struct _ns1__clientLogFilesResponse1 *)ptr);
		break;
	case SOAP_TYPE__ns1__NewOperationResponse:
		soap_serialize__ns1__NewOperationResponse(soap, (const struct _ns1__NewOperationResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__clientLogFiles:
		soap_serialize__ns1__clientLogFiles(soap, (const struct _ns1__clientLogFiles *)ptr);
		break;
	case SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse:
		soap_serialize__ns1__store_USCOREexec_USCOREfileResponse(soap, (const struct _ns1__store_USCOREexec_USCOREfileResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__store_USCOREexec_USCOREfile:
		soap_serialize__ns1__store_USCOREexec_USCOREfile(soap, (const struct _ns1__store_USCOREexec_USCOREfile *)ptr);
		break;
	case SOAP_TYPE__ns1__removeFileResponse:
		soap_serialize__ns1__removeFileResponse(soap, (const struct _ns1__removeFileResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__removeFile:
		soap_serialize__ns1__removeFile(soap, (const struct _ns1__removeFile *)ptr);
		break;
	case SOAP_TYPE__ns1__modifyFileResponse:
		soap_serialize__ns1__modifyFileResponse(soap, (const struct _ns1__modifyFileResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__modifyFile:
		soap_serialize__ns1__modifyFile(soap, (const struct _ns1__modifyFile *)ptr);
		break;
	case SOAP_TYPE__ns1__createFileResponse:
		soap_serialize__ns1__createFileResponse(soap, (const struct _ns1__createFileResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__createFile:
		soap_serialize__ns1__createFile(soap, (const struct _ns1__createFile *)ptr);
		break;
	case SOAP_TYPE__ns1__storeFileResponse:
		soap_serialize__ns1__storeFileResponse(soap, (const struct _ns1__storeFileResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__storeFile:
		soap_serialize__ns1__storeFile(soap, (const struct _ns1__storeFile *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__totalServFilesSizeResponse1:
		soap_serialize_PointerTo_ns1__totalServFilesSizeResponse1(soap, (struct _ns1__totalServFilesSizeResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__totalServFilesSize:
		soap_serialize_PointerTo_ns1__totalServFilesSize(soap, (struct _ns1__totalServFilesSize *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__filesStatisticsResponse1:
		soap_serialize_PointerTo_ns1__filesStatisticsResponse1(soap, (struct _ns1__filesStatisticsResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__filesStatistics:
		soap_serialize_PointerTo_ns1__filesStatistics(soap, (struct _ns1__filesStatistics *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__smallestServFileResponse1:
		soap_serialize_PointerTo_ns1__smallestServFileResponse1(soap, (struct _ns1__smallestServFileResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__smallestServFile:
		soap_serialize_PointerTo_ns1__smallestServFile(soap, (struct _ns1__smallestServFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__largestServFileResponse1:
		soap_serialize_PointerTo_ns1__largestServFileResponse1(soap, (struct _ns1__largestServFileResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__largestServFile:
		soap_serialize_PointerTo_ns1__largestServFile(soap, (struct _ns1__largestServFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__filesInCertainProgLanguageResponse1:
		soap_serialize_PointerTo_ns1__filesInCertainProgLanguageResponse1(soap, (struct _ns1__filesInCertainProgLanguageResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__filesInCertainProgLanguage:
		soap_serialize_PointerTo_ns1__filesInCertainProgLanguage(soap, (struct _ns1__filesInCertainProgLanguage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__servFilesResponse1:
		soap_serialize_PointerTo_ns1__servFilesResponse1(soap, (struct _ns1__servFilesResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__servFiles:
		soap_serialize_PointerTo_ns1__servFiles(soap, (struct _ns1__servFiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__clientLogFilesResponse1:
		soap_serialize_PointerTo_ns1__clientLogFilesResponse1(soap, (struct _ns1__clientLogFilesResponse1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__clientLogFiles:
		soap_serialize_PointerTo_ns1__clientLogFiles(soap, (struct _ns1__clientLogFiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeFileResponse:
		soap_serialize_PointerTo_ns1__removeFileResponse(soap, (struct _ns1__removeFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeFile:
		soap_serialize_PointerTo_ns1__removeFile(soap, (struct _ns1__removeFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__modifyFileResponse:
		soap_serialize_PointerTo_ns1__modifyFileResponse(soap, (struct _ns1__modifyFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__modifyFile:
		soap_serialize_PointerTo_ns1__modifyFile(soap, (struct _ns1__modifyFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createFileResponse:
		soap_serialize_PointerTo_ns1__createFileResponse(soap, (struct _ns1__createFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createFile:
		soap_serialize_PointerTo_ns1__createFile(soap, (struct _ns1__createFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeFileResponse:
		soap_serialize_PointerTo_ns1__storeFileResponse(soap, (struct _ns1__storeFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeFile:
		soap_serialize_PointerTo_ns1__storeFile(soap, (struct _ns1__storeFile *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__totalServFilesSize(struct soap *soap, struct __ns1__totalServFilesSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__totalServFilesSize = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__totalServFilesSize(struct soap *soap, const struct __ns1__totalServFilesSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__totalServFilesSize(soap, &a->ns1__totalServFilesSize);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__totalServFilesSize(struct soap *soap, const char *tag, int id, const struct __ns1__totalServFilesSize *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__totalServFilesSize(soap, "ns1:totalServFilesSize", -1, &a->ns1__totalServFilesSize, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__totalServFilesSize * SOAP_FMAC4 soap_in___ns1__totalServFilesSize(struct soap *soap, const char *tag, struct __ns1__totalServFilesSize *a, const char *type)
{
	size_t soap_flag_ns1__totalServFilesSize = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__totalServFilesSize*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__totalServFilesSize, sizeof(struct __ns1__totalServFilesSize), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__totalServFilesSize(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__totalServFilesSize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__totalServFilesSize(soap, "ns1:totalServFilesSize", &a->ns1__totalServFilesSize, ""))
				{	soap_flag_ns1__totalServFilesSize--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__totalServFilesSize * SOAP_FMAC4 soap_new___ns1__totalServFilesSize(struct soap *soap, int n)
{
	struct __ns1__totalServFilesSize *p;
	struct __ns1__totalServFilesSize *a = (struct __ns1__totalServFilesSize*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__totalServFilesSize));
	for (p = a; p && n--; p++)
		soap_default___ns1__totalServFilesSize(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__totalServFilesSize(struct soap *soap, const struct __ns1__totalServFilesSize *a, const char *tag, const char *type)
{
	if (soap_out___ns1__totalServFilesSize(soap, tag ? tag : "-ns1:totalServFilesSize", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__totalServFilesSize * SOAP_FMAC4 soap_get___ns1__totalServFilesSize(struct soap *soap, struct __ns1__totalServFilesSize *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__totalServFilesSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__filesStatistics(struct soap *soap, struct __ns1__filesStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__filesStatistics = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__filesStatistics(struct soap *soap, const struct __ns1__filesStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__filesStatistics(soap, &a->ns1__filesStatistics);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__filesStatistics(struct soap *soap, const char *tag, int id, const struct __ns1__filesStatistics *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__filesStatistics(soap, "ns1:filesStatistics", -1, &a->ns1__filesStatistics, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__filesStatistics * SOAP_FMAC4 soap_in___ns1__filesStatistics(struct soap *soap, const char *tag, struct __ns1__filesStatistics *a, const char *type)
{
	size_t soap_flag_ns1__filesStatistics = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__filesStatistics*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__filesStatistics, sizeof(struct __ns1__filesStatistics), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__filesStatistics(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__filesStatistics && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__filesStatistics(soap, "ns1:filesStatistics", &a->ns1__filesStatistics, ""))
				{	soap_flag_ns1__filesStatistics--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__filesStatistics * SOAP_FMAC4 soap_new___ns1__filesStatistics(struct soap *soap, int n)
{
	struct __ns1__filesStatistics *p;
	struct __ns1__filesStatistics *a = (struct __ns1__filesStatistics*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__filesStatistics));
	for (p = a; p && n--; p++)
		soap_default___ns1__filesStatistics(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__filesStatistics(struct soap *soap, const struct __ns1__filesStatistics *a, const char *tag, const char *type)
{
	if (soap_out___ns1__filesStatistics(soap, tag ? tag : "-ns1:filesStatistics", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__filesStatistics * SOAP_FMAC4 soap_get___ns1__filesStatistics(struct soap *soap, struct __ns1__filesStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__filesStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__smallestServFile(struct soap *soap, struct __ns1__smallestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__smallestServFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__smallestServFile(struct soap *soap, const struct __ns1__smallestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__smallestServFile(soap, &a->ns1__smallestServFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__smallestServFile(struct soap *soap, const char *tag, int id, const struct __ns1__smallestServFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__smallestServFile(soap, "ns1:smallestServFile", -1, &a->ns1__smallestServFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__smallestServFile * SOAP_FMAC4 soap_in___ns1__smallestServFile(struct soap *soap, const char *tag, struct __ns1__smallestServFile *a, const char *type)
{
	size_t soap_flag_ns1__smallestServFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__smallestServFile*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__smallestServFile, sizeof(struct __ns1__smallestServFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__smallestServFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__smallestServFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__smallestServFile(soap, "ns1:smallestServFile", &a->ns1__smallestServFile, ""))
				{	soap_flag_ns1__smallestServFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__smallestServFile * SOAP_FMAC4 soap_new___ns1__smallestServFile(struct soap *soap, int n)
{
	struct __ns1__smallestServFile *p;
	struct __ns1__smallestServFile *a = (struct __ns1__smallestServFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__smallestServFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__smallestServFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__smallestServFile(struct soap *soap, const struct __ns1__smallestServFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__smallestServFile(soap, tag ? tag : "-ns1:smallestServFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__smallestServFile * SOAP_FMAC4 soap_get___ns1__smallestServFile(struct soap *soap, struct __ns1__smallestServFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__smallestServFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__largestServFile(struct soap *soap, struct __ns1__largestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__largestServFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__largestServFile(struct soap *soap, const struct __ns1__largestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__largestServFile(soap, &a->ns1__largestServFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__largestServFile(struct soap *soap, const char *tag, int id, const struct __ns1__largestServFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__largestServFile(soap, "ns1:largestServFile", -1, &a->ns1__largestServFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__largestServFile * SOAP_FMAC4 soap_in___ns1__largestServFile(struct soap *soap, const char *tag, struct __ns1__largestServFile *a, const char *type)
{
	size_t soap_flag_ns1__largestServFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__largestServFile*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__largestServFile, sizeof(struct __ns1__largestServFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__largestServFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__largestServFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__largestServFile(soap, "ns1:largestServFile", &a->ns1__largestServFile, ""))
				{	soap_flag_ns1__largestServFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__largestServFile * SOAP_FMAC4 soap_new___ns1__largestServFile(struct soap *soap, int n)
{
	struct __ns1__largestServFile *p;
	struct __ns1__largestServFile *a = (struct __ns1__largestServFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__largestServFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__largestServFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__largestServFile(struct soap *soap, const struct __ns1__largestServFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__largestServFile(soap, tag ? tag : "-ns1:largestServFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__largestServFile * SOAP_FMAC4 soap_get___ns1__largestServFile(struct soap *soap, struct __ns1__largestServFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__largestServFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__filesInCertainProgLanguage(struct soap *soap, struct __ns1__filesInCertainProgLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__filesInCertainProgLanguage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__filesInCertainProgLanguage(struct soap *soap, const struct __ns1__filesInCertainProgLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__filesInCertainProgLanguage(soap, &a->ns1__filesInCertainProgLanguage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__filesInCertainProgLanguage(struct soap *soap, const char *tag, int id, const struct __ns1__filesInCertainProgLanguage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__filesInCertainProgLanguage(soap, "ns1:filesInCertainProgLanguage", -1, &a->ns1__filesInCertainProgLanguage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__filesInCertainProgLanguage * SOAP_FMAC4 soap_in___ns1__filesInCertainProgLanguage(struct soap *soap, const char *tag, struct __ns1__filesInCertainProgLanguage *a, const char *type)
{
	size_t soap_flag_ns1__filesInCertainProgLanguage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__filesInCertainProgLanguage*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__filesInCertainProgLanguage, sizeof(struct __ns1__filesInCertainProgLanguage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__filesInCertainProgLanguage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__filesInCertainProgLanguage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__filesInCertainProgLanguage(soap, "ns1:filesInCertainProgLanguage", &a->ns1__filesInCertainProgLanguage, ""))
				{	soap_flag_ns1__filesInCertainProgLanguage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__filesInCertainProgLanguage * SOAP_FMAC4 soap_new___ns1__filesInCertainProgLanguage(struct soap *soap, int n)
{
	struct __ns1__filesInCertainProgLanguage *p;
	struct __ns1__filesInCertainProgLanguage *a = (struct __ns1__filesInCertainProgLanguage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__filesInCertainProgLanguage));
	for (p = a; p && n--; p++)
		soap_default___ns1__filesInCertainProgLanguage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__filesInCertainProgLanguage(struct soap *soap, const struct __ns1__filesInCertainProgLanguage *a, const char *tag, const char *type)
{
	if (soap_out___ns1__filesInCertainProgLanguage(soap, tag ? tag : "-ns1:filesInCertainProgLanguage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__filesInCertainProgLanguage * SOAP_FMAC4 soap_get___ns1__filesInCertainProgLanguage(struct soap *soap, struct __ns1__filesInCertainProgLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__filesInCertainProgLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__servFiles(struct soap *soap, struct __ns1__servFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__servFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__servFiles(struct soap *soap, const struct __ns1__servFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__servFiles(soap, &a->ns1__servFiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__servFiles(struct soap *soap, const char *tag, int id, const struct __ns1__servFiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__servFiles(soap, "ns1:servFiles", -1, &a->ns1__servFiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__servFiles * SOAP_FMAC4 soap_in___ns1__servFiles(struct soap *soap, const char *tag, struct __ns1__servFiles *a, const char *type)
{
	size_t soap_flag_ns1__servFiles = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__servFiles*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__servFiles, sizeof(struct __ns1__servFiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__servFiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__servFiles && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__servFiles(soap, "ns1:servFiles", &a->ns1__servFiles, ""))
				{	soap_flag_ns1__servFiles--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__servFiles * SOAP_FMAC4 soap_new___ns1__servFiles(struct soap *soap, int n)
{
	struct __ns1__servFiles *p;
	struct __ns1__servFiles *a = (struct __ns1__servFiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__servFiles));
	for (p = a; p && n--; p++)
		soap_default___ns1__servFiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__servFiles(struct soap *soap, const struct __ns1__servFiles *a, const char *tag, const char *type)
{
	if (soap_out___ns1__servFiles(soap, tag ? tag : "-ns1:servFiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__servFiles * SOAP_FMAC4 soap_get___ns1__servFiles(struct soap *soap, struct __ns1__servFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__servFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__clientLogFiles(struct soap *soap, struct __ns1__clientLogFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__clientLogFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__clientLogFiles(struct soap *soap, const struct __ns1__clientLogFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__clientLogFiles(soap, &a->ns1__clientLogFiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__clientLogFiles(struct soap *soap, const char *tag, int id, const struct __ns1__clientLogFiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__clientLogFiles(soap, "ns1:clientLogFiles", -1, &a->ns1__clientLogFiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__clientLogFiles * SOAP_FMAC4 soap_in___ns1__clientLogFiles(struct soap *soap, const char *tag, struct __ns1__clientLogFiles *a, const char *type)
{
	size_t soap_flag_ns1__clientLogFiles = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__clientLogFiles*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__clientLogFiles, sizeof(struct __ns1__clientLogFiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__clientLogFiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__clientLogFiles && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__clientLogFiles(soap, "ns1:clientLogFiles", &a->ns1__clientLogFiles, ""))
				{	soap_flag_ns1__clientLogFiles--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__clientLogFiles * SOAP_FMAC4 soap_new___ns1__clientLogFiles(struct soap *soap, int n)
{
	struct __ns1__clientLogFiles *p;
	struct __ns1__clientLogFiles *a = (struct __ns1__clientLogFiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__clientLogFiles));
	for (p = a; p && n--; p++)
		soap_default___ns1__clientLogFiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__clientLogFiles(struct soap *soap, const struct __ns1__clientLogFiles *a, const char *tag, const char *type)
{
	if (soap_out___ns1__clientLogFiles(soap, tag ? tag : "-ns1:clientLogFiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__clientLogFiles * SOAP_FMAC4 soap_get___ns1__clientLogFiles(struct soap *soap, struct __ns1__clientLogFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__clientLogFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeFile(struct soap *soap, struct __ns1__removeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeFile(struct soap *soap, const struct __ns1__removeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__removeFile(soap, &a->ns1__removeFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeFile(struct soap *soap, const char *tag, int id, const struct __ns1__removeFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__removeFile(soap, "ns1:removeFile", -1, &a->ns1__removeFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeFile * SOAP_FMAC4 soap_in___ns1__removeFile(struct soap *soap, const char *tag, struct __ns1__removeFile *a, const char *type)
{
	size_t soap_flag_ns1__removeFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeFile*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeFile, sizeof(struct __ns1__removeFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__removeFile(soap, "ns1:removeFile", &a->ns1__removeFile, ""))
				{	soap_flag_ns1__removeFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__removeFile * SOAP_FMAC4 soap_new___ns1__removeFile(struct soap *soap, int n)
{
	struct __ns1__removeFile *p;
	struct __ns1__removeFile *a = (struct __ns1__removeFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__removeFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__removeFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeFile(struct soap *soap, const struct __ns1__removeFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeFile(soap, tag ? tag : "-ns1:removeFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeFile * SOAP_FMAC4 soap_get___ns1__removeFile(struct soap *soap, struct __ns1__removeFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyFile(struct soap *soap, struct __ns1__modifyFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyFile(struct soap *soap, const struct __ns1__modifyFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__modifyFile(soap, &a->ns1__modifyFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyFile(struct soap *soap, const char *tag, int id, const struct __ns1__modifyFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__modifyFile(soap, "ns1:modifyFile", -1, &a->ns1__modifyFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyFile * SOAP_FMAC4 soap_in___ns1__modifyFile(struct soap *soap, const char *tag, struct __ns1__modifyFile *a, const char *type)
{
	size_t soap_flag_ns1__modifyFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__modifyFile*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyFile, sizeof(struct __ns1__modifyFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__modifyFile(soap, "ns1:modifyFile", &a->ns1__modifyFile, ""))
				{	soap_flag_ns1__modifyFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__modifyFile * SOAP_FMAC4 soap_new___ns1__modifyFile(struct soap *soap, int n)
{
	struct __ns1__modifyFile *p;
	struct __ns1__modifyFile *a = (struct __ns1__modifyFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__modifyFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__modifyFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyFile(struct soap *soap, const struct __ns1__modifyFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__modifyFile(soap, tag ? tag : "-ns1:modifyFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyFile * SOAP_FMAC4 soap_get___ns1__modifyFile(struct soap *soap, struct __ns1__modifyFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createFile(struct soap *soap, struct __ns1__createFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createFile(struct soap *soap, const struct __ns1__createFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__createFile(soap, &a->ns1__createFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createFile(struct soap *soap, const char *tag, int id, const struct __ns1__createFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__createFile(soap, "ns1:createFile", -1, &a->ns1__createFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createFile * SOAP_FMAC4 soap_in___ns1__createFile(struct soap *soap, const char *tag, struct __ns1__createFile *a, const char *type)
{
	size_t soap_flag_ns1__createFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createFile*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createFile, sizeof(struct __ns1__createFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__createFile(soap, "ns1:createFile", &a->ns1__createFile, ""))
				{	soap_flag_ns1__createFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__createFile * SOAP_FMAC4 soap_new___ns1__createFile(struct soap *soap, int n)
{
	struct __ns1__createFile *p;
	struct __ns1__createFile *a = (struct __ns1__createFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__createFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__createFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createFile(struct soap *soap, const struct __ns1__createFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createFile(soap, tag ? tag : "-ns1:createFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createFile * SOAP_FMAC4 soap_get___ns1__createFile(struct soap *soap, struct __ns1__createFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__storeFile(struct soap *soap, struct __ns1__storeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__storeFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__storeFile(struct soap *soap, const struct __ns1__storeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__storeFile(soap, &a->ns1__storeFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__storeFile(struct soap *soap, const char *tag, int id, const struct __ns1__storeFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__storeFile(soap, "ns1:storeFile", -1, &a->ns1__storeFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeFile * SOAP_FMAC4 soap_in___ns1__storeFile(struct soap *soap, const char *tag, struct __ns1__storeFile *a, const char *type)
{
	size_t soap_flag_ns1__storeFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__storeFile*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__storeFile, sizeof(struct __ns1__storeFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__storeFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__storeFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__storeFile(soap, "ns1:storeFile", &a->ns1__storeFile, ""))
				{	soap_flag_ns1__storeFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__storeFile * SOAP_FMAC4 soap_new___ns1__storeFile(struct soap *soap, int n)
{
	struct __ns1__storeFile *p;
	struct __ns1__storeFile *a = (struct __ns1__storeFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__storeFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__storeFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__storeFile(struct soap *soap, const struct __ns1__storeFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__storeFile(soap, tag ? tag : "-ns1:storeFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeFile * SOAP_FMAC4 soap_get___ns1__storeFile(struct soap *soap, struct __ns1__storeFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__storeFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__totalServFilesSizeResponse1(struct soap *soap, struct _ns1__totalServFilesSizeResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__totalServFilesSizeResponse1(struct soap *soap, const struct _ns1__totalServFilesSizeResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__totalServFilesSizeResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__totalServFilesSizeResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__totalServFilesSizeResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__totalServFilesSizeResponse1 * SOAP_FMAC4 soap_in__ns1__totalServFilesSizeResponse1(struct soap *soap, const char *tag, struct _ns1__totalServFilesSizeResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__totalServFilesSizeResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__totalServFilesSizeResponse1, sizeof(struct _ns1__totalServFilesSizeResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__totalServFilesSizeResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__totalServFilesSizeResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__totalServFilesSizeResponse1, SOAP_TYPE__ns1__totalServFilesSizeResponse1, sizeof(struct _ns1__totalServFilesSizeResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__totalServFilesSizeResponse1 * SOAP_FMAC4 soap_new__ns1__totalServFilesSizeResponse1(struct soap *soap, int n)
{
	struct _ns1__totalServFilesSizeResponse1 *p;
	struct _ns1__totalServFilesSizeResponse1 *a = (struct _ns1__totalServFilesSizeResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__totalServFilesSizeResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__totalServFilesSizeResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__totalServFilesSizeResponse1(struct soap *soap, const struct _ns1__totalServFilesSizeResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__totalServFilesSizeResponse1(soap, tag ? tag : "ns1:totalServFilesSizeResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__totalServFilesSizeResponse1 * SOAP_FMAC4 soap_get__ns1__totalServFilesSizeResponse1(struct soap *soap, struct _ns1__totalServFilesSizeResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__totalServFilesSizeResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__totalServFilesSize(struct soap *soap, struct _ns1__totalServFilesSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__totalServFilesSize(struct soap *soap, const struct _ns1__totalServFilesSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__totalServFilesSize(struct soap *soap, const char *tag, int id, const struct _ns1__totalServFilesSize *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__totalServFilesSize), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__totalServFilesSize * SOAP_FMAC4 soap_in__ns1__totalServFilesSize(struct soap *soap, const char *tag, struct _ns1__totalServFilesSize *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__totalServFilesSize*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__totalServFilesSize, sizeof(struct _ns1__totalServFilesSize), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__totalServFilesSize(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__totalServFilesSize *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__totalServFilesSize, SOAP_TYPE__ns1__totalServFilesSize, sizeof(struct _ns1__totalServFilesSize), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__totalServFilesSize * SOAP_FMAC4 soap_new__ns1__totalServFilesSize(struct soap *soap, int n)
{
	struct _ns1__totalServFilesSize *p;
	struct _ns1__totalServFilesSize *a = (struct _ns1__totalServFilesSize*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__totalServFilesSize));
	for (p = a; p && n--; p++)
		soap_default__ns1__totalServFilesSize(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__totalServFilesSize(struct soap *soap, const struct _ns1__totalServFilesSize *a, const char *tag, const char *type)
{
	if (soap_out__ns1__totalServFilesSize(soap, tag ? tag : "ns1:totalServFilesSize", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__totalServFilesSize * SOAP_FMAC4 soap_get__ns1__totalServFilesSize(struct soap *soap, struct _ns1__totalServFilesSize *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__totalServFilesSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__filesStatisticsResponse1(struct soap *soap, struct _ns1__filesStatisticsResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__filesStatisticsResponse1(struct soap *soap, const struct _ns1__filesStatisticsResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__filesStatisticsResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__filesStatisticsResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__filesStatisticsResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__filesStatisticsResponse1 * SOAP_FMAC4 soap_in__ns1__filesStatisticsResponse1(struct soap *soap, const char *tag, struct _ns1__filesStatisticsResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__filesStatisticsResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__filesStatisticsResponse1, sizeof(struct _ns1__filesStatisticsResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__filesStatisticsResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__filesStatisticsResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__filesStatisticsResponse1, SOAP_TYPE__ns1__filesStatisticsResponse1, sizeof(struct _ns1__filesStatisticsResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__filesStatisticsResponse1 * SOAP_FMAC4 soap_new__ns1__filesStatisticsResponse1(struct soap *soap, int n)
{
	struct _ns1__filesStatisticsResponse1 *p;
	struct _ns1__filesStatisticsResponse1 *a = (struct _ns1__filesStatisticsResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__filesStatisticsResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__filesStatisticsResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__filesStatisticsResponse1(struct soap *soap, const struct _ns1__filesStatisticsResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__filesStatisticsResponse1(soap, tag ? tag : "ns1:filesStatisticsResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesStatisticsResponse1 * SOAP_FMAC4 soap_get__ns1__filesStatisticsResponse1(struct soap *soap, struct _ns1__filesStatisticsResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__filesStatisticsResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__filesStatistics(struct soap *soap, struct _ns1__filesStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__filesStatistics(struct soap *soap, const struct _ns1__filesStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__filesStatistics(struct soap *soap, const char *tag, int id, const struct _ns1__filesStatistics *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__filesStatistics), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__filesStatistics * SOAP_FMAC4 soap_in__ns1__filesStatistics(struct soap *soap, const char *tag, struct _ns1__filesStatistics *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__filesStatistics*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__filesStatistics, sizeof(struct _ns1__filesStatistics), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__filesStatistics(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__filesStatistics *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__filesStatistics, SOAP_TYPE__ns1__filesStatistics, sizeof(struct _ns1__filesStatistics), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__filesStatistics * SOAP_FMAC4 soap_new__ns1__filesStatistics(struct soap *soap, int n)
{
	struct _ns1__filesStatistics *p;
	struct _ns1__filesStatistics *a = (struct _ns1__filesStatistics*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__filesStatistics));
	for (p = a; p && n--; p++)
		soap_default__ns1__filesStatistics(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__filesStatistics(struct soap *soap, const struct _ns1__filesStatistics *a, const char *tag, const char *type)
{
	if (soap_out__ns1__filesStatistics(soap, tag ? tag : "ns1:filesStatistics", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesStatistics * SOAP_FMAC4 soap_get__ns1__filesStatistics(struct soap *soap, struct _ns1__filesStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__filesStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__smallestServFileResponse1(struct soap *soap, struct _ns1__smallestServFileResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__smallestServFileResponse1(struct soap *soap, const struct _ns1__smallestServFileResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__smallestServFileResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__smallestServFileResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__smallestServFileResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__smallestServFileResponse1 * SOAP_FMAC4 soap_in__ns1__smallestServFileResponse1(struct soap *soap, const char *tag, struct _ns1__smallestServFileResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__smallestServFileResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__smallestServFileResponse1, sizeof(struct _ns1__smallestServFileResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__smallestServFileResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__smallestServFileResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__smallestServFileResponse1, SOAP_TYPE__ns1__smallestServFileResponse1, sizeof(struct _ns1__smallestServFileResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__smallestServFileResponse1 * SOAP_FMAC4 soap_new__ns1__smallestServFileResponse1(struct soap *soap, int n)
{
	struct _ns1__smallestServFileResponse1 *p;
	struct _ns1__smallestServFileResponse1 *a = (struct _ns1__smallestServFileResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__smallestServFileResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__smallestServFileResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__smallestServFileResponse1(struct soap *soap, const struct _ns1__smallestServFileResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__smallestServFileResponse1(soap, tag ? tag : "ns1:smallestServFileResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__smallestServFileResponse1 * SOAP_FMAC4 soap_get__ns1__smallestServFileResponse1(struct soap *soap, struct _ns1__smallestServFileResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__smallestServFileResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__smallestServFile(struct soap *soap, struct _ns1__smallestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__smallestServFile(struct soap *soap, const struct _ns1__smallestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__smallestServFile(struct soap *soap, const char *tag, int id, const struct _ns1__smallestServFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__smallestServFile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__smallestServFile * SOAP_FMAC4 soap_in__ns1__smallestServFile(struct soap *soap, const char *tag, struct _ns1__smallestServFile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__smallestServFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__smallestServFile, sizeof(struct _ns1__smallestServFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__smallestServFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__smallestServFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__smallestServFile, SOAP_TYPE__ns1__smallestServFile, sizeof(struct _ns1__smallestServFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__smallestServFile * SOAP_FMAC4 soap_new__ns1__smallestServFile(struct soap *soap, int n)
{
	struct _ns1__smallestServFile *p;
	struct _ns1__smallestServFile *a = (struct _ns1__smallestServFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__smallestServFile));
	for (p = a; p && n--; p++)
		soap_default__ns1__smallestServFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__smallestServFile(struct soap *soap, const struct _ns1__smallestServFile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__smallestServFile(soap, tag ? tag : "ns1:smallestServFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__smallestServFile * SOAP_FMAC4 soap_get__ns1__smallestServFile(struct soap *soap, struct _ns1__smallestServFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__smallestServFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__largestServFileResponse1(struct soap *soap, struct _ns1__largestServFileResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__largestServFileResponse1(struct soap *soap, const struct _ns1__largestServFileResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__largestServFileResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__largestServFileResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__largestServFileResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__largestServFileResponse1 * SOAP_FMAC4 soap_in__ns1__largestServFileResponse1(struct soap *soap, const char *tag, struct _ns1__largestServFileResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__largestServFileResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__largestServFileResponse1, sizeof(struct _ns1__largestServFileResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__largestServFileResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__largestServFileResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__largestServFileResponse1, SOAP_TYPE__ns1__largestServFileResponse1, sizeof(struct _ns1__largestServFileResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__largestServFileResponse1 * SOAP_FMAC4 soap_new__ns1__largestServFileResponse1(struct soap *soap, int n)
{
	struct _ns1__largestServFileResponse1 *p;
	struct _ns1__largestServFileResponse1 *a = (struct _ns1__largestServFileResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__largestServFileResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__largestServFileResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__largestServFileResponse1(struct soap *soap, const struct _ns1__largestServFileResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__largestServFileResponse1(soap, tag ? tag : "ns1:largestServFileResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__largestServFileResponse1 * SOAP_FMAC4 soap_get__ns1__largestServFileResponse1(struct soap *soap, struct _ns1__largestServFileResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__largestServFileResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__largestServFile(struct soap *soap, struct _ns1__largestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__largestServFile(struct soap *soap, const struct _ns1__largestServFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__largestServFile(struct soap *soap, const char *tag, int id, const struct _ns1__largestServFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__largestServFile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__largestServFile * SOAP_FMAC4 soap_in__ns1__largestServFile(struct soap *soap, const char *tag, struct _ns1__largestServFile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__largestServFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__largestServFile, sizeof(struct _ns1__largestServFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__largestServFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__largestServFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__largestServFile, SOAP_TYPE__ns1__largestServFile, sizeof(struct _ns1__largestServFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__largestServFile * SOAP_FMAC4 soap_new__ns1__largestServFile(struct soap *soap, int n)
{
	struct _ns1__largestServFile *p;
	struct _ns1__largestServFile *a = (struct _ns1__largestServFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__largestServFile));
	for (p = a; p && n--; p++)
		soap_default__ns1__largestServFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__largestServFile(struct soap *soap, const struct _ns1__largestServFile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__largestServFile(soap, tag ? tag : "ns1:largestServFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__largestServFile * SOAP_FMAC4 soap_get__ns1__largestServFile(struct soap *soap, struct _ns1__largestServFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__largestServFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, struct _ns1__filesInCertainProgLanguageResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, const struct _ns1__filesInCertainProgLanguageResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__filesInCertainProgLanguageResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguageResponse1 * SOAP_FMAC4 soap_in__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, const char *tag, struct _ns1__filesInCertainProgLanguageResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__filesInCertainProgLanguageResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1, sizeof(struct _ns1__filesInCertainProgLanguageResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__filesInCertainProgLanguageResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__filesInCertainProgLanguageResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1, sizeof(struct _ns1__filesInCertainProgLanguageResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguageResponse1 * SOAP_FMAC4 soap_new__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, int n)
{
	struct _ns1__filesInCertainProgLanguageResponse1 *p;
	struct _ns1__filesInCertainProgLanguageResponse1 *a = (struct _ns1__filesInCertainProgLanguageResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__filesInCertainProgLanguageResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__filesInCertainProgLanguageResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, const struct _ns1__filesInCertainProgLanguageResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__filesInCertainProgLanguageResponse1(soap, tag ? tag : "ns1:filesInCertainProgLanguageResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguageResponse1 * SOAP_FMAC4 soap_get__ns1__filesInCertainProgLanguageResponse1(struct soap *soap, struct _ns1__filesInCertainProgLanguageResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__filesInCertainProgLanguageResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__filesInCertainProgLanguage(struct soap *soap, struct _ns1__filesInCertainProgLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__filesInCertainProgLanguage(struct soap *soap, const struct _ns1__filesInCertainProgLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__filesInCertainProgLanguage(struct soap *soap, const char *tag, int id, const struct _ns1__filesInCertainProgLanguage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__filesInCertainProgLanguage), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguage * SOAP_FMAC4 soap_in__ns1__filesInCertainProgLanguage(struct soap *soap, const char *tag, struct _ns1__filesInCertainProgLanguage *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__filesInCertainProgLanguage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__filesInCertainProgLanguage, sizeof(struct _ns1__filesInCertainProgLanguage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__filesInCertainProgLanguage(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__filesInCertainProgLanguage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__filesInCertainProgLanguage, SOAP_TYPE__ns1__filesInCertainProgLanguage, sizeof(struct _ns1__filesInCertainProgLanguage), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguage * SOAP_FMAC4 soap_new__ns1__filesInCertainProgLanguage(struct soap *soap, int n)
{
	struct _ns1__filesInCertainProgLanguage *p;
	struct _ns1__filesInCertainProgLanguage *a = (struct _ns1__filesInCertainProgLanguage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__filesInCertainProgLanguage));
	for (p = a; p && n--; p++)
		soap_default__ns1__filesInCertainProgLanguage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__filesInCertainProgLanguage(struct soap *soap, const struct _ns1__filesInCertainProgLanguage *a, const char *tag, const char *type)
{
	if (soap_out__ns1__filesInCertainProgLanguage(soap, tag ? tag : "ns1:filesInCertainProgLanguage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguage * SOAP_FMAC4 soap_get__ns1__filesInCertainProgLanguage(struct soap *soap, struct _ns1__filesInCertainProgLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__filesInCertainProgLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__servFilesResponse1(struct soap *soap, struct _ns1__servFilesResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__servFilesResponse1(struct soap *soap, const struct _ns1__servFilesResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__servFilesResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__servFilesResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__servFilesResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__servFilesResponse1 * SOAP_FMAC4 soap_in__ns1__servFilesResponse1(struct soap *soap, const char *tag, struct _ns1__servFilesResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__servFilesResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__servFilesResponse1, sizeof(struct _ns1__servFilesResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__servFilesResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__servFilesResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__servFilesResponse1, SOAP_TYPE__ns1__servFilesResponse1, sizeof(struct _ns1__servFilesResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__servFilesResponse1 * SOAP_FMAC4 soap_new__ns1__servFilesResponse1(struct soap *soap, int n)
{
	struct _ns1__servFilesResponse1 *p;
	struct _ns1__servFilesResponse1 *a = (struct _ns1__servFilesResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__servFilesResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__servFilesResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__servFilesResponse1(struct soap *soap, const struct _ns1__servFilesResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__servFilesResponse1(soap, tag ? tag : "ns1:servFilesResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__servFilesResponse1 * SOAP_FMAC4 soap_get__ns1__servFilesResponse1(struct soap *soap, struct _ns1__servFilesResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__servFilesResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__servFiles(struct soap *soap, struct _ns1__servFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__servFiles(struct soap *soap, const struct _ns1__servFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__servFiles(struct soap *soap, const char *tag, int id, const struct _ns1__servFiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__servFiles), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__servFiles * SOAP_FMAC4 soap_in__ns1__servFiles(struct soap *soap, const char *tag, struct _ns1__servFiles *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__servFiles*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__servFiles, sizeof(struct _ns1__servFiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__servFiles(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__servFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__servFiles, SOAP_TYPE__ns1__servFiles, sizeof(struct _ns1__servFiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__servFiles * SOAP_FMAC4 soap_new__ns1__servFiles(struct soap *soap, int n)
{
	struct _ns1__servFiles *p;
	struct _ns1__servFiles *a = (struct _ns1__servFiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__servFiles));
	for (p = a; p && n--; p++)
		soap_default__ns1__servFiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__servFiles(struct soap *soap, const struct _ns1__servFiles *a, const char *tag, const char *type)
{
	if (soap_out__ns1__servFiles(soap, tag ? tag : "ns1:servFiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__servFiles * SOAP_FMAC4 soap_get__ns1__servFiles(struct soap *soap, struct _ns1__servFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__servFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__clientLogFilesResponse1(struct soap *soap, struct _ns1__clientLogFilesResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__clientLogFilesResponse1(struct soap *soap, const struct _ns1__clientLogFilesResponse1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__clientLogFilesResponse1(struct soap *soap, const char *tag, int id, const struct _ns1__clientLogFilesResponse1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__clientLogFilesResponse1), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__clientLogFilesResponse1 * SOAP_FMAC4 soap_in__ns1__clientLogFilesResponse1(struct soap *soap, const char *tag, struct _ns1__clientLogFilesResponse1 *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__clientLogFilesResponse1*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__clientLogFilesResponse1, sizeof(struct _ns1__clientLogFilesResponse1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__clientLogFilesResponse1(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__clientLogFilesResponse1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__clientLogFilesResponse1, SOAP_TYPE__ns1__clientLogFilesResponse1, sizeof(struct _ns1__clientLogFilesResponse1), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__clientLogFilesResponse1 * SOAP_FMAC4 soap_new__ns1__clientLogFilesResponse1(struct soap *soap, int n)
{
	struct _ns1__clientLogFilesResponse1 *p;
	struct _ns1__clientLogFilesResponse1 *a = (struct _ns1__clientLogFilesResponse1*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__clientLogFilesResponse1));
	for (p = a; p && n--; p++)
		soap_default__ns1__clientLogFilesResponse1(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__clientLogFilesResponse1(struct soap *soap, const struct _ns1__clientLogFilesResponse1 *a, const char *tag, const char *type)
{
	if (soap_out__ns1__clientLogFilesResponse1(soap, tag ? tag : "ns1:clientLogFilesResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__clientLogFilesResponse1 * SOAP_FMAC4 soap_get__ns1__clientLogFilesResponse1(struct soap *soap, struct _ns1__clientLogFilesResponse1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__clientLogFilesResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__NewOperationResponse(struct soap *soap, struct _ns1__NewOperationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__NewOperationResponse(struct soap *soap, const struct _ns1__NewOperationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NewOperationResponse(struct soap *soap, const char *tag, int id, const struct _ns1__NewOperationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__NewOperationResponse), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__NewOperationResponse * SOAP_FMAC4 soap_in__ns1__NewOperationResponse(struct soap *soap, const char *tag, struct _ns1__NewOperationResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__NewOperationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__NewOperationResponse, sizeof(struct _ns1__NewOperationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__NewOperationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__NewOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__NewOperationResponse, SOAP_TYPE__ns1__NewOperationResponse, sizeof(struct _ns1__NewOperationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__NewOperationResponse * SOAP_FMAC4 soap_new__ns1__NewOperationResponse(struct soap *soap, int n)
{
	struct _ns1__NewOperationResponse *p;
	struct _ns1__NewOperationResponse *a = (struct _ns1__NewOperationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__NewOperationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__NewOperationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__NewOperationResponse(struct soap *soap, const struct _ns1__NewOperationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__NewOperationResponse(soap, tag ? tag : "ns1:NewOperationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__NewOperationResponse * SOAP_FMAC4 soap_get__ns1__NewOperationResponse(struct soap *soap, struct _ns1__NewOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NewOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__clientLogFiles(struct soap *soap, struct _ns1__clientLogFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__clientLogFiles(struct soap *soap, const struct _ns1__clientLogFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__clientLogFiles(struct soap *soap, const char *tag, int id, const struct _ns1__clientLogFiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__clientLogFiles), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__clientLogFiles * SOAP_FMAC4 soap_in__ns1__clientLogFiles(struct soap *soap, const char *tag, struct _ns1__clientLogFiles *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__clientLogFiles*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__clientLogFiles, sizeof(struct _ns1__clientLogFiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__clientLogFiles(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__clientLogFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__clientLogFiles, SOAP_TYPE__ns1__clientLogFiles, sizeof(struct _ns1__clientLogFiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__clientLogFiles * SOAP_FMAC4 soap_new__ns1__clientLogFiles(struct soap *soap, int n)
{
	struct _ns1__clientLogFiles *p;
	struct _ns1__clientLogFiles *a = (struct _ns1__clientLogFiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__clientLogFiles));
	for (p = a; p && n--; p++)
		soap_default__ns1__clientLogFiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__clientLogFiles(struct soap *soap, const struct _ns1__clientLogFiles *a, const char *tag, const char *type)
{
	if (soap_out__ns1__clientLogFiles(soap, tag ? tag : "ns1:clientLogFiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__clientLogFiles * SOAP_FMAC4 soap_get__ns1__clientLogFiles(struct soap *soap, struct _ns1__clientLogFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__clientLogFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, struct _ns1__store_USCOREexec_USCOREfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, const struct _ns1__store_USCOREexec_USCOREfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, const char *tag, int id, const struct _ns1__store_USCOREexec_USCOREfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__store_USCOREexec_USCOREfileResponse * SOAP_FMAC4 soap_in__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, const char *tag, struct _ns1__store_USCOREexec_USCOREfileResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__store_USCOREexec_USCOREfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse, sizeof(struct _ns1__store_USCOREexec_USCOREfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__store_USCOREexec_USCOREfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__store_USCOREexec_USCOREfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse, SOAP_TYPE__ns1__store_USCOREexec_USCOREfileResponse, sizeof(struct _ns1__store_USCOREexec_USCOREfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__store_USCOREexec_USCOREfileResponse * SOAP_FMAC4 soap_new__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, int n)
{
	struct _ns1__store_USCOREexec_USCOREfileResponse *p;
	struct _ns1__store_USCOREexec_USCOREfileResponse *a = (struct _ns1__store_USCOREexec_USCOREfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__store_USCOREexec_USCOREfileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__store_USCOREexec_USCOREfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, const struct _ns1__store_USCOREexec_USCOREfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__store_USCOREexec_USCOREfileResponse(soap, tag ? tag : "ns1:store_exec_fileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__store_USCOREexec_USCOREfileResponse * SOAP_FMAC4 soap_get__ns1__store_USCOREexec_USCOREfileResponse(struct soap *soap, struct _ns1__store_USCOREexec_USCOREfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__store_USCOREexec_USCOREfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__store_USCOREexec_USCOREfile(struct soap *soap, struct _ns1__store_USCOREexec_USCOREfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__store_USCOREexec_USCOREfile(struct soap *soap, const struct _ns1__store_USCOREexec_USCOREfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__store_USCOREexec_USCOREfile(struct soap *soap, const char *tag, int id, const struct _ns1__store_USCOREexec_USCOREfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__store_USCOREexec_USCOREfile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__store_USCOREexec_USCOREfile * SOAP_FMAC4 soap_in__ns1__store_USCOREexec_USCOREfile(struct soap *soap, const char *tag, struct _ns1__store_USCOREexec_USCOREfile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__store_USCOREexec_USCOREfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__store_USCOREexec_USCOREfile, sizeof(struct _ns1__store_USCOREexec_USCOREfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__store_USCOREexec_USCOREfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__store_USCOREexec_USCOREfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__store_USCOREexec_USCOREfile, SOAP_TYPE__ns1__store_USCOREexec_USCOREfile, sizeof(struct _ns1__store_USCOREexec_USCOREfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__store_USCOREexec_USCOREfile * SOAP_FMAC4 soap_new__ns1__store_USCOREexec_USCOREfile(struct soap *soap, int n)
{
	struct _ns1__store_USCOREexec_USCOREfile *p;
	struct _ns1__store_USCOREexec_USCOREfile *a = (struct _ns1__store_USCOREexec_USCOREfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__store_USCOREexec_USCOREfile));
	for (p = a; p && n--; p++)
		soap_default__ns1__store_USCOREexec_USCOREfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__store_USCOREexec_USCOREfile(struct soap *soap, const struct _ns1__store_USCOREexec_USCOREfile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__store_USCOREexec_USCOREfile(soap, tag ? tag : "ns1:store_exec_file", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__store_USCOREexec_USCOREfile * SOAP_FMAC4 soap_get__ns1__store_USCOREexec_USCOREfile(struct soap *soap, struct _ns1__store_USCOREexec_USCOREfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__store_USCOREexec_USCOREfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__removeFileResponse(struct soap *soap, struct _ns1__removeFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__removeFileResponse(struct soap *soap, const struct _ns1__removeFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeFileResponse(struct soap *soap, const char *tag, int id, const struct _ns1__removeFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeFileResponse), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__removeFileResponse * SOAP_FMAC4 soap_in__ns1__removeFileResponse(struct soap *soap, const char *tag, struct _ns1__removeFileResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__removeFileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeFileResponse, sizeof(struct _ns1__removeFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__removeFileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__removeFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeFileResponse, SOAP_TYPE__ns1__removeFileResponse, sizeof(struct _ns1__removeFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__removeFileResponse * SOAP_FMAC4 soap_new__ns1__removeFileResponse(struct soap *soap, int n)
{
	struct _ns1__removeFileResponse *p;
	struct _ns1__removeFileResponse *a = (struct _ns1__removeFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__removeFileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__removeFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__removeFileResponse(struct soap *soap, const struct _ns1__removeFileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__removeFileResponse(soap, tag ? tag : "ns1:removeFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__removeFileResponse * SOAP_FMAC4 soap_get__ns1__removeFileResponse(struct soap *soap, struct _ns1__removeFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__removeFile(struct soap *soap, struct _ns1__removeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__removeFile(struct soap *soap, const struct _ns1__removeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeFile(struct soap *soap, const char *tag, int id, const struct _ns1__removeFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeFile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__removeFile * SOAP_FMAC4 soap_in__ns1__removeFile(struct soap *soap, const char *tag, struct _ns1__removeFile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__removeFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeFile, sizeof(struct _ns1__removeFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__removeFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__removeFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeFile, SOAP_TYPE__ns1__removeFile, sizeof(struct _ns1__removeFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__removeFile * SOAP_FMAC4 soap_new__ns1__removeFile(struct soap *soap, int n)
{
	struct _ns1__removeFile *p;
	struct _ns1__removeFile *a = (struct _ns1__removeFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__removeFile));
	for (p = a; p && n--; p++)
		soap_default__ns1__removeFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__removeFile(struct soap *soap, const struct _ns1__removeFile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__removeFile(soap, tag ? tag : "ns1:removeFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__removeFile * SOAP_FMAC4 soap_get__ns1__removeFile(struct soap *soap, struct _ns1__removeFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__modifyFileResponse(struct soap *soap, struct _ns1__modifyFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__modifyFileResponse(struct soap *soap, const struct _ns1__modifyFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifyFileResponse(struct soap *soap, const char *tag, int id, const struct _ns1__modifyFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifyFileResponse), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__modifyFileResponse * SOAP_FMAC4 soap_in__ns1__modifyFileResponse(struct soap *soap, const char *tag, struct _ns1__modifyFileResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__modifyFileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyFileResponse, sizeof(struct _ns1__modifyFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__modifyFileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__modifyFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__modifyFileResponse, SOAP_TYPE__ns1__modifyFileResponse, sizeof(struct _ns1__modifyFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__modifyFileResponse * SOAP_FMAC4 soap_new__ns1__modifyFileResponse(struct soap *soap, int n)
{
	struct _ns1__modifyFileResponse *p;
	struct _ns1__modifyFileResponse *a = (struct _ns1__modifyFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__modifyFileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__modifyFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__modifyFileResponse(struct soap *soap, const struct _ns1__modifyFileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__modifyFileResponse(soap, tag ? tag : "ns1:modifyFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__modifyFileResponse * SOAP_FMAC4 soap_get__ns1__modifyFileResponse(struct soap *soap, struct _ns1__modifyFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifyFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__modifyFile(struct soap *soap, struct _ns1__modifyFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__modifyFile(struct soap *soap, const struct _ns1__modifyFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifyFile(struct soap *soap, const char *tag, int id, const struct _ns1__modifyFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifyFile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__modifyFile * SOAP_FMAC4 soap_in__ns1__modifyFile(struct soap *soap, const char *tag, struct _ns1__modifyFile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__modifyFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyFile, sizeof(struct _ns1__modifyFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__modifyFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__modifyFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__modifyFile, SOAP_TYPE__ns1__modifyFile, sizeof(struct _ns1__modifyFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__modifyFile * SOAP_FMAC4 soap_new__ns1__modifyFile(struct soap *soap, int n)
{
	struct _ns1__modifyFile *p;
	struct _ns1__modifyFile *a = (struct _ns1__modifyFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__modifyFile));
	for (p = a; p && n--; p++)
		soap_default__ns1__modifyFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__modifyFile(struct soap *soap, const struct _ns1__modifyFile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__modifyFile(soap, tag ? tag : "ns1:modifyFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__modifyFile * SOAP_FMAC4 soap_get__ns1__modifyFile(struct soap *soap, struct _ns1__modifyFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifyFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createFileResponse(struct soap *soap, struct _ns1__createFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createFileResponse(struct soap *soap, const struct _ns1__createFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createFileResponse(struct soap *soap, const char *tag, int id, const struct _ns1__createFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createFileResponse), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createFileResponse * SOAP_FMAC4 soap_in__ns1__createFileResponse(struct soap *soap, const char *tag, struct _ns1__createFileResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__createFileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createFileResponse, sizeof(struct _ns1__createFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createFileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__createFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createFileResponse, SOAP_TYPE__ns1__createFileResponse, sizeof(struct _ns1__createFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__createFileResponse * SOAP_FMAC4 soap_new__ns1__createFileResponse(struct soap *soap, int n)
{
	struct _ns1__createFileResponse *p;
	struct _ns1__createFileResponse *a = (struct _ns1__createFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__createFileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__createFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createFileResponse(struct soap *soap, const struct _ns1__createFileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__createFileResponse(soap, tag ? tag : "ns1:createFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createFileResponse * SOAP_FMAC4 soap_get__ns1__createFileResponse(struct soap *soap, struct _ns1__createFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createFile(struct soap *soap, struct _ns1__createFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createFile(struct soap *soap, const struct _ns1__createFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createFile(struct soap *soap, const char *tag, int id, const struct _ns1__createFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createFile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createFile * SOAP_FMAC4 soap_in__ns1__createFile(struct soap *soap, const char *tag, struct _ns1__createFile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__createFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createFile, sizeof(struct _ns1__createFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__createFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createFile, SOAP_TYPE__ns1__createFile, sizeof(struct _ns1__createFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__createFile * SOAP_FMAC4 soap_new__ns1__createFile(struct soap *soap, int n)
{
	struct _ns1__createFile *p;
	struct _ns1__createFile *a = (struct _ns1__createFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__createFile));
	for (p = a; p && n--; p++)
		soap_default__ns1__createFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createFile(struct soap *soap, const struct _ns1__createFile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__createFile(soap, tag ? tag : "ns1:createFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createFile * SOAP_FMAC4 soap_get__ns1__createFile(struct soap *soap, struct _ns1__createFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__storeFileResponse(struct soap *soap, struct _ns1__storeFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__storeFileResponse(struct soap *soap, const struct _ns1__storeFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeFileResponse(struct soap *soap, const char *tag, int id, const struct _ns1__storeFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeFileResponse), type))
		return soap->error;
	if (!a->out)
	{	if (soap_element_empty(soap, "out", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "out", -1, (char*const*)&a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__storeFileResponse * SOAP_FMAC4 soap_in__ns1__storeFileResponse(struct soap *soap, const char *tag, struct _ns1__storeFileResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__storeFileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeFileResponse, sizeof(struct _ns1__storeFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__storeFileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "out", (char**)&a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__storeFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeFileResponse, SOAP_TYPE__ns1__storeFileResponse, sizeof(struct _ns1__storeFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__storeFileResponse * SOAP_FMAC4 soap_new__ns1__storeFileResponse(struct soap *soap, int n)
{
	struct _ns1__storeFileResponse *p;
	struct _ns1__storeFileResponse *a = (struct _ns1__storeFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__storeFileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__storeFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__storeFileResponse(struct soap *soap, const struct _ns1__storeFileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__storeFileResponse(soap, tag ? tag : "ns1:storeFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__storeFileResponse * SOAP_FMAC4 soap_get__ns1__storeFileResponse(struct soap *soap, struct _ns1__storeFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__storeFile(struct soap *soap, struct _ns1__storeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__storeFile(struct soap *soap, const struct _ns1__storeFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeFile(struct soap *soap, const char *tag, int id, const struct _ns1__storeFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeFile), type))
		return soap->error;
	if (!a->in)
	{	if (soap_element_empty(soap, "in", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "in", -1, (char*const*)&a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__storeFile * SOAP_FMAC4 soap_in__ns1__storeFile(struct soap *soap, const char *tag, struct _ns1__storeFile *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _ns1__storeFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeFile, sizeof(struct _ns1__storeFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__storeFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "in", (char**)&a->in, "xsd:string"))
				{	soap_flag_in--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__storeFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeFile, SOAP_TYPE__ns1__storeFile, sizeof(struct _ns1__storeFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__storeFile * SOAP_FMAC4 soap_new__ns1__storeFile(struct soap *soap, int n)
{
	struct _ns1__storeFile *p;
	struct _ns1__storeFile *a = (struct _ns1__storeFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__storeFile));
	for (p = a; p && n--; p++)
		soap_default__ns1__storeFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__storeFile(struct soap *soap, const struct _ns1__storeFile *a, const char *tag, const char *type)
{
	if (soap_out__ns1__storeFile(soap, tag ? tag : "ns1:storeFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__storeFile * SOAP_FMAC4 soap_get__ns1__storeFile(struct soap *soap, struct _ns1__storeFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__totalServFilesSizeResponse1(struct soap *soap, struct _ns1__totalServFilesSizeResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__totalServFilesSizeResponse1))
		soap_serialize__ns1__totalServFilesSizeResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__totalServFilesSizeResponse1(struct soap *soap, const char *tag, int id, struct _ns1__totalServFilesSizeResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__totalServFilesSizeResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__totalServFilesSizeResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__totalServFilesSizeResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__totalServFilesSizeResponse1(struct soap *soap, const char *tag, struct _ns1__totalServFilesSizeResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__totalServFilesSizeResponse1 **)soap_malloc(soap, sizeof(struct _ns1__totalServFilesSizeResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__totalServFilesSizeResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__totalServFilesSizeResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__totalServFilesSizeResponse1, sizeof(struct _ns1__totalServFilesSizeResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__totalServFilesSizeResponse1(struct soap *soap, struct _ns1__totalServFilesSizeResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__totalServFilesSizeResponse1(soap, tag ? tag : "ns1:totalServFilesSizeResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__totalServFilesSizeResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__totalServFilesSizeResponse1(struct soap *soap, struct _ns1__totalServFilesSizeResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__totalServFilesSizeResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__totalServFilesSize(struct soap *soap, struct _ns1__totalServFilesSize *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__totalServFilesSize))
		soap_serialize__ns1__totalServFilesSize(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__totalServFilesSize(struct soap *soap, const char *tag, int id, struct _ns1__totalServFilesSize *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__totalServFilesSize, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__totalServFilesSize(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__totalServFilesSize ** SOAP_FMAC4 soap_in_PointerTo_ns1__totalServFilesSize(struct soap *soap, const char *tag, struct _ns1__totalServFilesSize **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__totalServFilesSize **)soap_malloc(soap, sizeof(struct _ns1__totalServFilesSize *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__totalServFilesSize(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__totalServFilesSize **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__totalServFilesSize, sizeof(struct _ns1__totalServFilesSize), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__totalServFilesSize(struct soap *soap, struct _ns1__totalServFilesSize *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__totalServFilesSize(soap, tag ? tag : "ns1:totalServFilesSize", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__totalServFilesSize ** SOAP_FMAC4 soap_get_PointerTo_ns1__totalServFilesSize(struct soap *soap, struct _ns1__totalServFilesSize **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__totalServFilesSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__filesStatisticsResponse1(struct soap *soap, struct _ns1__filesStatisticsResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__filesStatisticsResponse1))
		soap_serialize__ns1__filesStatisticsResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__filesStatisticsResponse1(struct soap *soap, const char *tag, int id, struct _ns1__filesStatisticsResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__filesStatisticsResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__filesStatisticsResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__filesStatisticsResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__filesStatisticsResponse1(struct soap *soap, const char *tag, struct _ns1__filesStatisticsResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__filesStatisticsResponse1 **)soap_malloc(soap, sizeof(struct _ns1__filesStatisticsResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__filesStatisticsResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__filesStatisticsResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__filesStatisticsResponse1, sizeof(struct _ns1__filesStatisticsResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__filesStatisticsResponse1(struct soap *soap, struct _ns1__filesStatisticsResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__filesStatisticsResponse1(soap, tag ? tag : "ns1:filesStatisticsResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesStatisticsResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__filesStatisticsResponse1(struct soap *soap, struct _ns1__filesStatisticsResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__filesStatisticsResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__filesStatistics(struct soap *soap, struct _ns1__filesStatistics *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__filesStatistics))
		soap_serialize__ns1__filesStatistics(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__filesStatistics(struct soap *soap, const char *tag, int id, struct _ns1__filesStatistics *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__filesStatistics, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__filesStatistics(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__filesStatistics ** SOAP_FMAC4 soap_in_PointerTo_ns1__filesStatistics(struct soap *soap, const char *tag, struct _ns1__filesStatistics **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__filesStatistics **)soap_malloc(soap, sizeof(struct _ns1__filesStatistics *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__filesStatistics(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__filesStatistics **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__filesStatistics, sizeof(struct _ns1__filesStatistics), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__filesStatistics(struct soap *soap, struct _ns1__filesStatistics *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__filesStatistics(soap, tag ? tag : "ns1:filesStatistics", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesStatistics ** SOAP_FMAC4 soap_get_PointerTo_ns1__filesStatistics(struct soap *soap, struct _ns1__filesStatistics **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__filesStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__smallestServFileResponse1(struct soap *soap, struct _ns1__smallestServFileResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__smallestServFileResponse1))
		soap_serialize__ns1__smallestServFileResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__smallestServFileResponse1(struct soap *soap, const char *tag, int id, struct _ns1__smallestServFileResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__smallestServFileResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__smallestServFileResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__smallestServFileResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__smallestServFileResponse1(struct soap *soap, const char *tag, struct _ns1__smallestServFileResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__smallestServFileResponse1 **)soap_malloc(soap, sizeof(struct _ns1__smallestServFileResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__smallestServFileResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__smallestServFileResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__smallestServFileResponse1, sizeof(struct _ns1__smallestServFileResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__smallestServFileResponse1(struct soap *soap, struct _ns1__smallestServFileResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__smallestServFileResponse1(soap, tag ? tag : "ns1:smallestServFileResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__smallestServFileResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__smallestServFileResponse1(struct soap *soap, struct _ns1__smallestServFileResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__smallestServFileResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__smallestServFile(struct soap *soap, struct _ns1__smallestServFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__smallestServFile))
		soap_serialize__ns1__smallestServFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__smallestServFile(struct soap *soap, const char *tag, int id, struct _ns1__smallestServFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__smallestServFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__smallestServFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__smallestServFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__smallestServFile(struct soap *soap, const char *tag, struct _ns1__smallestServFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__smallestServFile **)soap_malloc(soap, sizeof(struct _ns1__smallestServFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__smallestServFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__smallestServFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__smallestServFile, sizeof(struct _ns1__smallestServFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__smallestServFile(struct soap *soap, struct _ns1__smallestServFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__smallestServFile(soap, tag ? tag : "ns1:smallestServFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__smallestServFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__smallestServFile(struct soap *soap, struct _ns1__smallestServFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__smallestServFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__largestServFileResponse1(struct soap *soap, struct _ns1__largestServFileResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__largestServFileResponse1))
		soap_serialize__ns1__largestServFileResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__largestServFileResponse1(struct soap *soap, const char *tag, int id, struct _ns1__largestServFileResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__largestServFileResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__largestServFileResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__largestServFileResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__largestServFileResponse1(struct soap *soap, const char *tag, struct _ns1__largestServFileResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__largestServFileResponse1 **)soap_malloc(soap, sizeof(struct _ns1__largestServFileResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__largestServFileResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__largestServFileResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__largestServFileResponse1, sizeof(struct _ns1__largestServFileResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__largestServFileResponse1(struct soap *soap, struct _ns1__largestServFileResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__largestServFileResponse1(soap, tag ? tag : "ns1:largestServFileResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__largestServFileResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__largestServFileResponse1(struct soap *soap, struct _ns1__largestServFileResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__largestServFileResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__largestServFile(struct soap *soap, struct _ns1__largestServFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__largestServFile))
		soap_serialize__ns1__largestServFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__largestServFile(struct soap *soap, const char *tag, int id, struct _ns1__largestServFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__largestServFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__largestServFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__largestServFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__largestServFile(struct soap *soap, const char *tag, struct _ns1__largestServFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__largestServFile **)soap_malloc(soap, sizeof(struct _ns1__largestServFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__largestServFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__largestServFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__largestServFile, sizeof(struct _ns1__largestServFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__largestServFile(struct soap *soap, struct _ns1__largestServFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__largestServFile(soap, tag ? tag : "ns1:largestServFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__largestServFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__largestServFile(struct soap *soap, struct _ns1__largestServFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__largestServFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__filesInCertainProgLanguageResponse1(struct soap *soap, struct _ns1__filesInCertainProgLanguageResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1))
		soap_serialize__ns1__filesInCertainProgLanguageResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__filesInCertainProgLanguageResponse1(struct soap *soap, const char *tag, int id, struct _ns1__filesInCertainProgLanguageResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__filesInCertainProgLanguageResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguageResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__filesInCertainProgLanguageResponse1(struct soap *soap, const char *tag, struct _ns1__filesInCertainProgLanguageResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__filesInCertainProgLanguageResponse1 **)soap_malloc(soap, sizeof(struct _ns1__filesInCertainProgLanguageResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__filesInCertainProgLanguageResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__filesInCertainProgLanguageResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__filesInCertainProgLanguageResponse1, sizeof(struct _ns1__filesInCertainProgLanguageResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__filesInCertainProgLanguageResponse1(struct soap *soap, struct _ns1__filesInCertainProgLanguageResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__filesInCertainProgLanguageResponse1(soap, tag ? tag : "ns1:filesInCertainProgLanguageResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguageResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__filesInCertainProgLanguageResponse1(struct soap *soap, struct _ns1__filesInCertainProgLanguageResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__filesInCertainProgLanguageResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__filesInCertainProgLanguage(struct soap *soap, struct _ns1__filesInCertainProgLanguage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__filesInCertainProgLanguage))
		soap_serialize__ns1__filesInCertainProgLanguage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__filesInCertainProgLanguage(struct soap *soap, const char *tag, int id, struct _ns1__filesInCertainProgLanguage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__filesInCertainProgLanguage, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__filesInCertainProgLanguage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguage ** SOAP_FMAC4 soap_in_PointerTo_ns1__filesInCertainProgLanguage(struct soap *soap, const char *tag, struct _ns1__filesInCertainProgLanguage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__filesInCertainProgLanguage **)soap_malloc(soap, sizeof(struct _ns1__filesInCertainProgLanguage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__filesInCertainProgLanguage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__filesInCertainProgLanguage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__filesInCertainProgLanguage, sizeof(struct _ns1__filesInCertainProgLanguage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__filesInCertainProgLanguage(struct soap *soap, struct _ns1__filesInCertainProgLanguage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__filesInCertainProgLanguage(soap, tag ? tag : "ns1:filesInCertainProgLanguage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__filesInCertainProgLanguage ** SOAP_FMAC4 soap_get_PointerTo_ns1__filesInCertainProgLanguage(struct soap *soap, struct _ns1__filesInCertainProgLanguage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__filesInCertainProgLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__servFilesResponse1(struct soap *soap, struct _ns1__servFilesResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__servFilesResponse1))
		soap_serialize__ns1__servFilesResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__servFilesResponse1(struct soap *soap, const char *tag, int id, struct _ns1__servFilesResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__servFilesResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__servFilesResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__servFilesResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__servFilesResponse1(struct soap *soap, const char *tag, struct _ns1__servFilesResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__servFilesResponse1 **)soap_malloc(soap, sizeof(struct _ns1__servFilesResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__servFilesResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__servFilesResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__servFilesResponse1, sizeof(struct _ns1__servFilesResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__servFilesResponse1(struct soap *soap, struct _ns1__servFilesResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__servFilesResponse1(soap, tag ? tag : "ns1:servFilesResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__servFilesResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__servFilesResponse1(struct soap *soap, struct _ns1__servFilesResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__servFilesResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__servFiles(struct soap *soap, struct _ns1__servFiles *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__servFiles))
		soap_serialize__ns1__servFiles(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__servFiles(struct soap *soap, const char *tag, int id, struct _ns1__servFiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__servFiles, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__servFiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__servFiles ** SOAP_FMAC4 soap_in_PointerTo_ns1__servFiles(struct soap *soap, const char *tag, struct _ns1__servFiles **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__servFiles **)soap_malloc(soap, sizeof(struct _ns1__servFiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__servFiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__servFiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__servFiles, sizeof(struct _ns1__servFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__servFiles(struct soap *soap, struct _ns1__servFiles *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__servFiles(soap, tag ? tag : "ns1:servFiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__servFiles ** SOAP_FMAC4 soap_get_PointerTo_ns1__servFiles(struct soap *soap, struct _ns1__servFiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__servFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__clientLogFilesResponse1(struct soap *soap, struct _ns1__clientLogFilesResponse1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__clientLogFilesResponse1))
		soap_serialize__ns1__clientLogFilesResponse1(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__clientLogFilesResponse1(struct soap *soap, const char *tag, int id, struct _ns1__clientLogFilesResponse1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__clientLogFilesResponse1, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__clientLogFilesResponse1(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__clientLogFilesResponse1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__clientLogFilesResponse1(struct soap *soap, const char *tag, struct _ns1__clientLogFilesResponse1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__clientLogFilesResponse1 **)soap_malloc(soap, sizeof(struct _ns1__clientLogFilesResponse1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__clientLogFilesResponse1(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__clientLogFilesResponse1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__clientLogFilesResponse1, sizeof(struct _ns1__clientLogFilesResponse1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__clientLogFilesResponse1(struct soap *soap, struct _ns1__clientLogFilesResponse1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__clientLogFilesResponse1(soap, tag ? tag : "ns1:clientLogFilesResponse1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__clientLogFilesResponse1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__clientLogFilesResponse1(struct soap *soap, struct _ns1__clientLogFilesResponse1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__clientLogFilesResponse1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__clientLogFiles(struct soap *soap, struct _ns1__clientLogFiles *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__clientLogFiles))
		soap_serialize__ns1__clientLogFiles(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__clientLogFiles(struct soap *soap, const char *tag, int id, struct _ns1__clientLogFiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__clientLogFiles, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__clientLogFiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__clientLogFiles ** SOAP_FMAC4 soap_in_PointerTo_ns1__clientLogFiles(struct soap *soap, const char *tag, struct _ns1__clientLogFiles **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__clientLogFiles **)soap_malloc(soap, sizeof(struct _ns1__clientLogFiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__clientLogFiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__clientLogFiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__clientLogFiles, sizeof(struct _ns1__clientLogFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__clientLogFiles(struct soap *soap, struct _ns1__clientLogFiles *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__clientLogFiles(soap, tag ? tag : "ns1:clientLogFiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__clientLogFiles ** SOAP_FMAC4 soap_get_PointerTo_ns1__clientLogFiles(struct soap *soap, struct _ns1__clientLogFiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__clientLogFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeFileResponse(struct soap *soap, struct _ns1__removeFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeFileResponse))
		soap_serialize__ns1__removeFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeFileResponse(struct soap *soap, const char *tag, int id, struct _ns1__removeFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__removeFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__removeFileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeFileResponse(struct soap *soap, const char *tag, struct _ns1__removeFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__removeFileResponse **)soap_malloc(soap, sizeof(struct _ns1__removeFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__removeFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__removeFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeFileResponse, sizeof(struct _ns1__removeFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeFileResponse(struct soap *soap, struct _ns1__removeFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__removeFileResponse(soap, tag ? tag : "ns1:removeFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__removeFileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeFileResponse(struct soap *soap, struct _ns1__removeFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeFile(struct soap *soap, struct _ns1__removeFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeFile))
		soap_serialize__ns1__removeFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeFile(struct soap *soap, const char *tag, int id, struct _ns1__removeFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__removeFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__removeFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeFile(struct soap *soap, const char *tag, struct _ns1__removeFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__removeFile **)soap_malloc(soap, sizeof(struct _ns1__removeFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__removeFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__removeFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeFile, sizeof(struct _ns1__removeFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeFile(struct soap *soap, struct _ns1__removeFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__removeFile(soap, tag ? tag : "ns1:removeFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__removeFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeFile(struct soap *soap, struct _ns1__removeFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__modifyFileResponse(struct soap *soap, struct _ns1__modifyFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__modifyFileResponse))
		soap_serialize__ns1__modifyFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__modifyFileResponse(struct soap *soap, const char *tag, int id, struct _ns1__modifyFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__modifyFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__modifyFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__modifyFileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__modifyFileResponse(struct soap *soap, const char *tag, struct _ns1__modifyFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__modifyFileResponse **)soap_malloc(soap, sizeof(struct _ns1__modifyFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__modifyFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__modifyFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__modifyFileResponse, sizeof(struct _ns1__modifyFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__modifyFileResponse(struct soap *soap, struct _ns1__modifyFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__modifyFileResponse(soap, tag ? tag : "ns1:modifyFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__modifyFileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__modifyFileResponse(struct soap *soap, struct _ns1__modifyFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__modifyFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__modifyFile(struct soap *soap, struct _ns1__modifyFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__modifyFile))
		soap_serialize__ns1__modifyFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__modifyFile(struct soap *soap, const char *tag, int id, struct _ns1__modifyFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__modifyFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__modifyFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__modifyFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__modifyFile(struct soap *soap, const char *tag, struct _ns1__modifyFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__modifyFile **)soap_malloc(soap, sizeof(struct _ns1__modifyFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__modifyFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__modifyFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__modifyFile, sizeof(struct _ns1__modifyFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__modifyFile(struct soap *soap, struct _ns1__modifyFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__modifyFile(soap, tag ? tag : "ns1:modifyFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__modifyFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__modifyFile(struct soap *soap, struct _ns1__modifyFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__modifyFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createFileResponse(struct soap *soap, struct _ns1__createFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createFileResponse))
		soap_serialize__ns1__createFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createFileResponse(struct soap *soap, const char *tag, int id, struct _ns1__createFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createFileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__createFileResponse(struct soap *soap, const char *tag, struct _ns1__createFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createFileResponse **)soap_malloc(soap, sizeof(struct _ns1__createFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__createFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createFileResponse, sizeof(struct _ns1__createFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createFileResponse(struct soap *soap, struct _ns1__createFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__createFileResponse(soap, tag ? tag : "ns1:createFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createFileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__createFileResponse(struct soap *soap, struct _ns1__createFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createFile(struct soap *soap, struct _ns1__createFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createFile))
		soap_serialize__ns1__createFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createFile(struct soap *soap, const char *tag, int id, struct _ns1__createFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__createFile(struct soap *soap, const char *tag, struct _ns1__createFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createFile **)soap_malloc(soap, sizeof(struct _ns1__createFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__createFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createFile, sizeof(struct _ns1__createFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createFile(struct soap *soap, struct _ns1__createFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__createFile(soap, tag ? tag : "ns1:createFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__createFile(struct soap *soap, struct _ns1__createFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeFileResponse(struct soap *soap, struct _ns1__storeFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeFileResponse))
		soap_serialize__ns1__storeFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeFileResponse(struct soap *soap, const char *tag, int id, struct _ns1__storeFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__storeFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__storeFileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeFileResponse(struct soap *soap, const char *tag, struct _ns1__storeFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__storeFileResponse **)soap_malloc(soap, sizeof(struct _ns1__storeFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__storeFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__storeFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeFileResponse, sizeof(struct _ns1__storeFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeFileResponse(struct soap *soap, struct _ns1__storeFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__storeFileResponse(soap, tag ? tag : "ns1:storeFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__storeFileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeFileResponse(struct soap *soap, struct _ns1__storeFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeFile(struct soap *soap, struct _ns1__storeFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeFile))
		soap_serialize__ns1__storeFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeFile(struct soap *soap, const char *tag, int id, struct _ns1__storeFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__storeFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__storeFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeFile(struct soap *soap, const char *tag, struct _ns1__storeFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__storeFile **)soap_malloc(soap, sizeof(struct _ns1__storeFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__storeFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__storeFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeFile, sizeof(struct _ns1__storeFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeFile(struct soap *soap, struct _ns1__storeFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__storeFile(soap, tag ? tag : "ns1:storeFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__storeFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeFile(struct soap *soap, struct _ns1__storeFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
